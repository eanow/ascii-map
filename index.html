<!DOCTYPE html>
<head>
    <style type='text/css'>
        p.map_pixel {
        font-family: monospace;
        line-height: 0em;
        font-size: 30px;
        -moz-user-select: -moz-none;
        -khtml-user-select: none;
        -webkit-user-select: none;
        -o-user-select: none;
        user-select: none;
        }
    </style>
</head>

<script type="text/javascript">
//some global settings for the ascii palette
const empty_tile='█';
const map_mapping={
    "ground": {
        "D": ['.',':',';','∙'],
        "G": ['"','‟','‘','`',','],
        "R": ['°','σ','¤'],
        "W": ["≈",'~'],
        "T": ["+"],
        "H": ["-"],
    },
    "wall": {
        "W": ["╬"],
        "N": [")","(","|"],
        "T": ["Ω"],
        "D": ["∩"],
    },
    "actor": {
        "P": ["P"],
        "M": ["M"],
    }
}

//palette state object
let ps={}; 
//which of the palette subtypes is selected
ps.tab="ground";
//flags and variables used for drawing boxes, i.e. for painting ground
ps.box_draw=false;
ps.box_start_row=0;
ps.box_start_col=0;
//flags for line mode, i.e. for painting walls
ps.line_draw=false;
//size of the map being drawn
ps.rows=0;
ps.cols=0;

function synthesize_map() {
    //create a combined map by merging all layers
    let line="";
    let update_clip="";
    let symbol_set=null;
    document.getElementById("clip_area").textContent="";
    for (let ii=0; ii<ps.rows; ii+=1) {
        line="";
        for (let jj=0; jj<ps.cols; jj+=1) {
            let coord_tail="_"+ii+"_"+jj;
            ground_layer=document.getElementById("ground_map"+coord_tail).textContent;
            wall_layer=document.getElementById("wall_map"+coord_tail).textContent;
            actor_layer=document.getElementById("actor_map"+coord_tail).textContent;
            temp_layer=document.getElementById("temp_map"+coord_tail).textContent;
            symbol_set=map_mapping.ground[ground_layer];
            console.log("using ground");
            //Temp > actors > wall > ground, assuming not empty tile
            if (wall_layer !== empty_tile) {
                symbol_set=map_mapping.wall[wall_layer];
                console.log("using Wall");
            }
            if (actor_layer !== empty_tile) {
                symbol_set=map_mapping.actor[actor_layer];
                console.log("using actor");
            }
            if (temp_layer !== empty_tile) {
                symbol_set=map_mapping.ground[temp_layer];
                console.log("using temp");
            }
            paint=symbol_set[(Math.random() * symbol_set.length) | 0];
            document.getElementById("map_canvas"+coord_tail).textContent=paint;
            line=line+paint;
        }
        if (ii===0) {
            update_clip=line;
        } else {
            update_clip=update_clip+"\n"+line;
        }
    }
    document.getElementById("clip_area").textContent=update_clip;
}

function current_marker() {
    let rval="0";
    let picked=null;
    let radio_elements=null;
    //base on palette
    switch(ps.tab) {
        case "ground":
            radio_elements=document.getElementsByName("ground_material");
            for(let ii=0; ii<radio_elements.length; ii+=1) {
                if (radio_elements[ii].checked) {
                    picked=radio_elements[ii].id;
                }
            }    
            console.log("current_marker: "+picked+ " selected");
            switch(picked) {
                case "ground_dirt":
                    rval='D';
                    break;
                case "ground_grass":
                    rval='G';
                    break;
                case "ground_rock":
                    rval='R';
                    break;
                case "ground_water":
                    rval='W';
                    break;
                case "ground_tile":
                    rval='T';
                    break;
                case "ground_wood":
                    rval='H';
                    break;
            }
            break;
        case "wall":
            radio_elements=document.getElementsByName("wall_material");
            for(let ii=0; ii<radio_elements.length; ii+=1) {
                if (radio_elements[ii].checked) {
                    picked=radio_elements[ii].id;
                }
            }
            console.log("current_marker: "+picked+ " selected");
            switch(picked) {
                case "wall_constructed":
                    rval='W';
                    break;
                case "wall_natural":
                    rval='N';
                    break;
                case "wall_terrain":
                    rval='T';
                    break;
                case "wall_door":
                    rval='D';
                    break;   
            }
            break;
        case "actor":
            radio_elements=document.getElementsByName("actor_token");
            for(let ii=0; ii<radio_elements.length; ii+=1) {
                if (radio_elements[ii].checked) {
                    picked=radio_elements[ii].id;
                }
            } 
            console.log("current_marker: "+picked+ " selected");
            switch(picked) {
                case "actor_player":
                    rval='P';
                    break;
                case "actor_monster":
                    rval='M';
                    break; 
            }
            break;
    }
    return rval;
}
function edit_ground() {
    ps.tab="ground";
    document.getElementById("ground_palette").style.visibility='visible';
    document.getElementById("wall_palette").style.visibility='hidden';
    document.getElementById("actor_palette").style.visibility='hidden';
}
function edit_wall() {
    ps.tab="wall";
    document.getElementById("ground_palette").style.visibility='hidden';
    document.getElementById("wall_palette").style.visibility='visible';
    document.getElementById("actor_palette").style.visibility='hidden';
}
function edit_actor() {
    ps.tab="actor";
    document.getElementById("ground_palette").style.visibility='hidden';
    document.getElementById("wall_palette").style.visibility='hidden';
    document.getElementById("actor_palette").style.visibility='visible';
}
function click_rewrite(event) {
    let myCol = event.target.id.split("_")[3];
    let myRow = event.target.id.split("_")[2];
    document.getElementById("col_display").textContent=myCol;
    document.getElementById("row_display").textContent=myRow;
    let paint=current_marker();
    switch(ps.tab) {
        case "actor":
            let coords=event.target.id.replace("map_canvas","actor_map");
            document.getElementById(coords).textContent=paint;
            synthesize_map();
            break;
    }
}
function clear_map(map_box) {
    for (let ii = 0; ii < ps.cols; ii+=1) {
        for (let jj= 0; jj < ps.rows; jj+=1) {
            switch (map_box) {
                case "temp":
                    let coords="temp_map_"+jj+"_"+ii;
                    //console.log("attempting to clear "+coords);
                    document.getElementById(coords).textContent=empty_tile;
                    break;
            }
        }
    }
}
function populate_map(map_box) {
    for (let ii=0; ii<ps.rows; ii+=1) {
        let new_row=document.createElement("p");
        new_row.id=map_box+"_"+ii;
        new_row.className="map_pixel";
        for (let jj=0; jj<ps.cols; jj+=1) {
            let new_col=document.createElement("span");
            new_col.id=map_box+"_"+ii+"_"+jj;
            new_col.textContent=empty_tile;
            new_row.append(new_col);
        }
        document.getElementById(map_box).append(new_row);
    }
}
function canvas_mousedown_event(event) {
    let myCol = event.target.id.split("_")[3];
    let myRow = event.target.id.split("_")[2];
    //functionality will alter based on mode
    switch(ps.tab) {
        case "ground":
            ps.box_start_col = event.target.id.split("_")[3];
            ps.box_start_row = event.target.id.split("_")[2];
            ps.box_draw = true;
            clear_map("temp");
            update_square(ps.box_start_col,myCol,ps.box_start_row,myRow,"temp");
            synthesize_map();
            break;
        case "wall":
            ps.line_draw = true;
            let paint=current_marker();
            coords=event.target.id.replace("map_canvas","wall_map");
            document.getElementById(coords).textContent=paint;
            synthesize_map();  
            break;
    }
    document.getElementById("state").textContent="Down";
}
function canvas_mouseup_event(event) {
    //functionality will alter based on mode
    switch(ps.tab) {
    case "ground":
        let myCol = event.target.id.split("_")[3];
        let myRow = event.target.id.split("_")[2];
        update_square(ps.box_start_col,myCol,ps.box_start_row,myRow,"ground");
        clear_map("temp");
        synthesize_map();
        break;
    }
    document.getElementById("state").textContent="Up";
    ps.box_draw=false;
    ps.line_draw=false;
}
function canvas_mouseenter_event(event) {
    if (ps.box_draw || ps.line_draw) {
        let myCol = event.target.id.split("_")[3];
        let myRow = event.target.id.split("_")[2];
        let paint=current_marker();
        switch(ps.tab) {
            case "wall":
                coords=event.target.id.replace("map_canvas","wall_map");
                document.getElementById(coords).textContent=paint;
                synthesize_map();
            break;
            case "ground":
                clear_map("temp");
                update_square(ps.box_start_col,myCol,ps.box_start_row,myRow,"temp");
                synthesize_map();
            break;
        }
    }
}
function fresh_map() {
    //get input
    ps.rows=parseInt(document.getElementById("num_rows").value,10);
    ps.cols=parseInt(document.getElementById("num_cols").value,10);
    document.getElementById("clip_area").textContent="";
    //empty the map area
    document.getElementById("map_canvas").replaceChildren();
    //empty the holders
    document.getElementById("ground_map").replaceChildren();
    document.getElementById("wall_map").replaceChildren();
    document.getElementById("actor_map").replaceChildren();
    document.getElementById("temp_map").replaceChildren();
    //fill with ps.rows worth of p elements
    populate_map("ground_map");
    populate_map("temp_map");
    populate_map("wall_map");
    populate_map("actor_map");
    populate_map("map_canvas");

    //start will a full dirt ground
    update_square(0,ps.cols-1,0,ps.rows-1,"ground");
    console.log("Creating Fresh Map");
    synthesize_map();

    //assign click events to each item in map_canvas
    for (let rr=0; rr<ps.rows; rr+=1) {
        for (let cc=0; cc<ps.cols; cc+=1) {
            let coords="_"+rr+"_"+cc;
            document.getElementById("map_canvas"+coords).addEventListener('click',click_rewrite);
            document.getElementById("map_canvas"+coords).addEventListener('mousedown',canvas_mousedown_event);
            document.getElementById("map_canvas"+coords).addEventListener('mouseup',canvas_mouseup_event);
            document.getElementById("map_canvas"+coords).addEventListener('mouseenter',canvas_mouseenter_event);
        }
    }
    //handling the situation where the mouse is let go outside the canvas
    document.body.addEventListener("mouseup",function(even) {ps.box_draw=false;ps.line_draw=false});
}
function update_square(x1, x2, y1, y2, map_box) {
    //swap if first is larger
    if (parseInt(x1,10)>parseInt(x2,10)) {
        drawX1=parseInt(x2,10);
        drawX2=parseInt(x1,10);
    } else {
        drawX1=parseInt(x1,10);
        drawX2=parseInt(x2,10);
    }
    if (parseInt(y1,10)>parseInt(y2,10)) {
        drawY1=parseInt(y2,10);
        drawY2=parseInt(y1,10);
    } else {
        drawY1=parseInt(y1,10);
        drawY2=parseInt(y2,10);
    }
    console.log("drawing a square");
    console.log(drawX1+" "+drawX2+" "+drawY1+" "+drawY2)
    let paint=current_marker();
    for (ii=drawX1; ii<=drawX2; ii++) {
        for (jj=drawY1; jj<=drawY2; jj++) {
            let coord_tail="_"+jj+"_"+ii;
            switch(map_box) {
                case "ground":
                    document.getElementById("ground_map"+coord_tail).textContent=paint;
                    break;
                case "temp":
                    document.getElementById("temp_map"+coord_tail).textContent=paint;
                    break;
            }
        }
    }
}
</script>



<p></p>
<div style="width: 100%; display:table;">
    <div style="display: table-row;">
        <div class="map_canvas" id="map_canvas" style="display: table-cell; width: 5%; margin:10;">

        </div>
        <div class="drawing_palette" style="display: table-cell; width: auto; float:left;margin:10;"></div>
            <div style="display: table-row;">
                <div class="palette_select" style="display: table-cell;">
                    <button onclick="edit_ground()">Ground</button><br />
                    <button onclick="edit_wall()">Walls</button><br />
                    <button onclick="edit_actor()">Actors</button><br />
                </div>
            </div>
            <!-- palette for ground; stuff like dirt, grass, interior tile, etc -->
            <div style="display: table-row; visibility: visible;" id="ground_palette">
                <div style="display: table-cell;">
                    <input type="radio" name="ground_material" value="ground_dirt" id="ground_dirt" checked>
                    <label for="ground_dirt">Dirt</label>
                    <br />
                    <input type="radio" name="ground_material" value="ground_grass" id="ground_grass">
                    <label for="ground_grass">Grass</label>
                    <br />
                    <input type="radio" name="ground_material" value="ground_rock" id="ground_rock">
                    <label for="ground_rock">Rocky</label>
                    <br />
                    <input type="radio" name="ground_material" value="ground_water" id="ground_water">
                    <label for="ground_water">Water</label>
                    <br />
                    <input type="radio" name="ground_material" value="ground_tile" id="ground_tile">
                    <label for="ground_tile">Tile/Finished Stone</label>
                    <br />
                    <input type="radio" name="ground_material" value="ground_wood" id="ground_wood">
                    <label for="ground_wood">Wooden</label>
                </div>
            </div>
            <!-- palette for walls -->
            <div style="display: table-row; visibility: hidden;" id="wall_palette">
                <div style="display: table-cell;">
                    <input type="radio" name="wall_material" value="wall_constructed" id="wall_constructed" checked>
                    <label for="wall_constructed">Constructed Wall</label>
                    <br />
                    <input type="radio" name="wall_material" value="wall_natural" id="wall_natural">
                    <label for="wall_natural">Natural Wall</label>
                    <br />
                    <input type="radio" name="wall_material" value="wall_terrain" id="wall_terrain">
                    <label for="wall_terrain">Terrain Obstactle</label>
                    <br />
                    <input type="radio" name="wall_material" value="wall_door" id="wall_door">
                    <label for="wall_door">Door</label>
                    <br />
                </div>
            </div>
            <!-- palette for actors -->
            <div style="display: table-row; visibility: hidden;" id="actor_palette">
                <div style="display: table-cell;">
                    <input type="radio" name="actor_token" value="actor_player" id="actor_player" checked>
                    <label for="actor_player">Player Character</label>
                    <br />
                    <input type="radio" name="actor_token" value="actor_monster" id="actor_monster">
                    <label for="actor_monster">Monster</label>
                    <br />
                </div>
            </div>
        </div>
    </div>
</div>
<br />
<hr>

<p></p>
<!-- debug -->
State:<span id="state"></span>
X:<span id="col_display"></span>
Y:<span id="row_display"></span>
<br />
<!-- create map -->
<label for="num_rows">Rows:</label>
<input type="number" id="num_rows" name="Rows">
<label for="num_cols">Columns:</label>
<input type="number" id="num_cols" name="Cols">
<button onclick="fresh_map()">Create New Map</button> 
<button onclick="synthesize_map()">Merge Map</button>
<br />
<!--holder maps-->
<div style="display: table;">
    <div style="display: table-row;"></div>
        <div class="temp_map" id="temp_map" style="display: table-cell;"></div>
        <div style="width: 10px; display: table-cell;"></div>
        <div class="ground_map" id="ground_map" style="display: table-cell;"></div>
        <div style="width: 10px; display: table-cell;"></div>
        <div class="wall_map" id="wall_map" style="display: table-cell;"></div>
        <div style="width: 10px; display: table-cell;"></div>
        <div class="actor_map" id="actor_map" style="display: table-cell;"></div>
    </div>
</div>
<!--copypasta area-->
<textarea id="clip_area">
</textarea>
</html>
